package genswagger

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"regexp"
	"strings"

	"github.com/gengo/grpc-gateway/protoc-gen-grpc-gateway/descriptor"
)

type param struct {
	*descriptor.File
	reg *descriptor.Registry
}

type binding struct {
	*descriptor.Binding
}

type swaggerInfoObject struct {
	Version string `json:"version"`
	Title   string `json:"title"`
}

type swaggerObject struct {
	Swagger     string                   `json:"swagger"`
	Info        swaggerInfoObject        `json:"info"`
	Host        string                   `json:"host,omitempty"`
	BasePath    string                   `json:"basePath,omitempty"`
	Schemes     []string                 `json:"schemes"`
	Consumes    []string                 `json:"consumes"`
	Produces    []string                 `json:"produces"`
	Paths       swaggerPathsObject       `json:"paths"`
	Definitions swaggerDefinitionsObject `json:"definitions"`
}

type swaggerPathsObject map[string]swaggerPathItemObject
type swaggerPathItemObject struct {
	Get    *swaggerOperationObject `json:"get,omitempty"`
	Delete *swaggerOperationObject `json:"delete,omitempty"`
	Post   *swaggerOperationObject `json:"post,omitempty"`
	Put    *swaggerOperationObject `json:"put,omitempty"`
}

type swaggerOperationObject struct {
	Summary    string                  `json:"summary"`
	Responses  swaggerResponsesObject  `json:"responses"`
	Parameters swaggerParametersObject `json:"parameters,omitempty"`
}

type swaggerParametersObject []swaggerParameterObject
type swaggerParameterObject struct {
	Name        string `json:"name"`
	Description string `json:"description,omitempty"`
	In          string `json:"in,omitempty"`
	Required    bool   `json:"required"`
	Type        string `json:"type,omitempty"`
	Format      string `json:"format,omitempty"`

	// Or you can explicitly refer to another type. If this is defined all
	// other fields should be empty
	Schema *swaggerSchemaObject `json:"schema,omitempty"`
}

type swaggerResponsesObject map[string]swaggerResponseObject

type swaggerResponseObject struct {
	Description string              `json:"description"`
	Schema      swaggerSchemaObject `json:"schema"`
}

type swaggerSchemaObject struct {
	Ref        string                                 `json:"$ref,omitempty"`
	Type       string                                 `json:"type,omitempty"`
	Properties map[string]swaggerSchemaPropertyObject `json:"properties,omitempty"`
}

type swaggerSchemaPropertyObject struct {
	//Name   string `json:"name"`
	Type   string `json:"type,omitempty"`
	Format string `json:"format,omitempty"`

	// Or you can explicitly refer to another type. If this is defined all
	// other fields should be empty
	Ref string `json:"$ref,omitempty"`
}

type swaggerReferenceObject struct {
	Ref string `json:"$ref"`
}

type swaggerDefinitionsObject map[string]swaggerSchemaObject

type messageMap map[string]*descriptor.Message

// Discover all possible Messages that can be generated by the services.
func findServicesMessages(s []*descriptor.Service, reg *descriptor.Registry, m messageMap) {
	for _, svc := range s {
		for _, meth := range svc.Methods {
			m[meth.RequestType.FQMN()] = meth.RequestType
			findNestedMessages(meth.RequestType, reg, m)
			m[meth.ResponseType.FQMN()] = meth.RequestType
			findNestedMessages(meth.ResponseType, reg, m)
		}
	}
}

// Recursively discover all possible Messages that can be generated by the services.
func findNestedMessages(message *descriptor.Message, reg *descriptor.Registry, m messageMap) {
	// Iterate over all the fields that
	for _, t := range message.Fields {

		fieldType := t.GetTypeName()
		// If the type is an empty string then it is a proto primitive
		if fieldType != "" {
			if _, ok := m[fieldType]; !ok {
				msg, err := reg.LookupMsg("", fieldType)
				if err != nil {
					panic(err)
				}
				m[fieldType] = msg
				findNestedMessages(msg, reg, m)
			}
		}
	}

	//for _, svc := range message.NestedType {
	//	for _, meth := range svc.Methods {
	//		toReturn[meth.RequestType.FQMN()] = meth.RequestType
	//		toReturn[meth.ResponseType.FQMN()] = meth.RequestType
	//	}
	//}
}

func renderMessagesAsDefinition(messages messageMap) swaggerDefinitionsObject {
	toReturn := swaggerDefinitionsObject{}

	for _, msg := range messages {
		swaggerSchemaObject := swaggerSchemaObject{
			Properties: map[string]swaggerSchemaPropertyObject{},
		}
		for _, field := range msg.Fields {
			var fieldType, fieldFormat string
			primitive := true
			// Field type and format from http://swagger.io/specification/ in the
			// "Data Types" table
			switch field.FieldDescriptorProto.Type.String() {
			case "TYPE_DOUBLE":
				fieldType = "number"
				fieldFormat = "double"
				break
			case "TYPE_FLOAT":
				fieldType = "number"
				fieldFormat = "float"
				break
			case "TYPE_INT64":
				fieldType = "integer"
				fieldFormat = "int64"
				break
			case "TYPE_UINT64":
				fieldType = "integer"
				fieldFormat = "int64"
				break
			case "TYPE_INT32":
				fieldType = "integer"
				fieldFormat = "int32"
				break
			case "TYPE_FIXED64":
				fieldType = "integer"
				fieldFormat = "int64"
				break
			case "TYPE_FIXED32":
				fieldType = "integer"
				fieldFormat = "int32"
				break
			case "TYPE_BOOL":
				fieldType = "boolean"
				fieldFormat = "boolean"
				break
			case "TYPE_STRING":
				fieldType = "string"
				fieldFormat = "string"
				break
			case "TYPE_GROUP":
				// WTF is a group? is this sufficient?
				primitive = false
				break
			case "TYPE_MESSAGE":
				// Check in here if it is the special date/datetime proto and
				// serialize as a primitive date object
				primitive = false
				fieldType = ""
				fieldFormat = ""
				break
			case "TYPE_BYTES":
				fieldType = "string"
				fieldFormat = "byte"
				break
			case "TYPE_UINT32":
				fieldType = "integer"
				fieldFormat = "int64"
				break
			case "TYPE_ENUM":
				fieldType = "integer"
				fieldFormat = "int64"
				break
			case "TYPE_SFIXED32":
				fieldType = "integer"
				fieldFormat = "int32"
				break
			case "TYPE_SFIXED64":
				fieldType = "integer"
				fieldFormat = "int32"
				break
			case "TYPE_SINT32":
				fieldType = "integer"
				fieldFormat = "int32"
				break
			case "TYPE_SINT64":
				fieldType = "integer"
				fieldFormat = "int64"
				break
			default:
				fieldType = field.FieldDescriptorProto.Type.String()
				fieldFormat = "UNKNOWN"
			}

			if primitive {
				swaggerSchemaObject.Properties[field.GetName()] = swaggerSchemaPropertyObject{
					Type:   fieldType,
					Format: fieldFormat,
				}
			} else {
				swaggerSchemaObject.Properties[field.GetName()] = swaggerSchemaPropertyObject{
					Ref: "#/definitions/" + field.GetTypeName(),
				}
			}
		}
		toReturn[msg.FQMN()] = swaggerSchemaObject
	}

	return toReturn
}

// Swagger expects paths of the form /path/{string_value} but grpc-gateway paths are expected to be of the form /path/{string_value=strprefix/*}. This should reformat it correctly.
func templateToSwaggerPath(path string) string {
	// It seems like the right thing to do here is to just use
	// strings.Split(path, "/") but that breaks badly when you hit a url like
	// /{my_field=prefix/*}/ and end up with 2 sections representing my_field.
	// Instead do the right thing and write a small pushdown (counter) automata
	// for it.
	parts := []string{}
	depth := 0
	buffer := ""
	for _, char := range path {
		switch char {
		case '{':
			// Push on the stack
			depth += 1
			buffer += string(char)
			break
		case '}':
			if depth == 0 {
				panic("Encountered } without matching { before it.")
			}
			// Pop from the stack
			depth -= 1
			buffer += "}"
		case '/':
			if depth == 0 {
				parts = append(parts, buffer)
				buffer = ""
				// Since the stack was empty when we hit the '/' we are done with this
				// section.
				continue
			}
		default:
			buffer += string(char)
			break
		}
	}

	// Now append the last element to parts
	parts = append(parts, buffer)

	// Parts is now an array of segments of the path. Interestingly, since the
	// syntax for this subsection CAN be handled by a regexp since it has no
	// memory.
	re := regexp.MustCompile("{([a-z][a-z0-9_]*).*}")
	for index, part := range parts {
		parts[index] = re.ReplaceAllString(part, "{$1}")
	}

	return strings.Join(parts, "/")
}

func renderServices(services []*descriptor.Service, paths swaggerPathsObject) error {
	for _, svc := range services {
		for _, meth := range svc.Methods {
			if meth.GetClientStreaming() || meth.GetServerStreaming() {
				return errors.New(`Service uses streaming, which is not currently supported. Maybe you would like to implement it? It wouldn't be that hard and we don't bite. Why don't you send a pull request to https://github.com/gengo/grpc-gateway?`)
			}
			for _, b := range meth.Bindings {
				// Iterate over all the swagger parameters
				parameters := swaggerParametersObject{}
				for _, parameter := range b.PathParams {
					parameters = append(parameters, swaggerParameterObject{
						Name:     parameter.String(),
						In:       "path",
						Required: true,
						// Parameters in gRPC-Gateway can only be strings?
						Type:   "string",
						Format: "string",
					})
				}
				// Now check if there is a body parameter
				if b.Body != nil {
					parameters = append(parameters, swaggerParameterObject{
						In:       "body",
						Required: true,
						Schema: &swaggerSchemaObject{
							Ref: fmt.Sprintf("#/definitions/%s", meth.RequestType.FQMN()),
						},
					})
				}

				pathItemObject := swaggerPathItemObject{}
				operationObject := &swaggerOperationObject{
					Summary:    fmt.Sprintf("%s.%s", svc.GetName(), meth.GetName()),
					Parameters: parameters,
					Responses: swaggerResponsesObject{
						"default": swaggerResponseObject{
							Description: "Description",
							Schema: swaggerSchemaObject{
								Ref: fmt.Sprintf("#/definitions/%s", meth.ResponseType.FQMN()),
							},
						},
					},
				}

				switch b.HTTPMethod {
				case "DELETE":
					pathItemObject.Delete = operationObject
					break
				case "GET":
					pathItemObject.Get = operationObject
					break
				case "POST":
					pathItemObject.Post = operationObject
					break
				case "PUT":
					pathItemObject.Put = operationObject
					break
				}
				paths[templateToSwaggerPath(b.PathTmpl.Template)] = pathItemObject
			}
		}
	}

	// Success! return nil on the error object
	return nil
}

// This function is called with a param which contains the entire definition of a method.
func applyTemplate(p param) (string, error) {
	s := swaggerObject{
		// Swagger 2.0 is the version of this document
		Swagger:  "2.0",
		Schemes:  []string{"http", "https"},
		Consumes: []string{"application/json"},
		Produces: []string{"application/json"},
		Paths:    make(swaggerPathsObject),
	}

	renderServices(p.Services, s.Paths)

	m := messageMap{}
	findServicesMessages(p.Services, p.reg, m)
	s.Definitions = renderMessagesAsDefinition(m)

	//s.Definitions[leak] = swaggerSchemaObject{
	//	Properties: map[string]swaggerSchemaPropertyObject{
	//		"hardcoded": swaggerSchemaPropertyObject{
	//			Type:   "string",
	//			Format: "string",
	//		},
	//	},
	//}

	w := bytes.NewBuffer(nil)
	enc := json.NewEncoder(w)
	enc.Encode(&s)

	return w.String(), nil
}
